## 信号量的定义
1. 信号量是一个整数值的对象，可以用两个函数来操作它：sem_wait()和sem_post()。因为信号量的初始值能够决定其行为，所以首先
要初始化信号量，才能调用其他函数与之交互。
   ``` 
        #include <semaphore.h> 
        sem_t s;
        sem_init(&s, 0, 1);
   ```
1. 上述代码申明了一个信号量s，通过第三个参数，将它的值初始化为1，sem_init的第二个参数基本都设置为0，表示信号量是在同一个
进程的多个线程共享的。信号量初始化后就可以调sem_wait或sem_post与之交互。sem_wait要么立刻返回（调用时信号量的值大于等于
1），要么会让调用线程挂起，直到之后的一个post操作。也可能多个调用线程都调用sem_wait因此都在队列中等待被唤醒。sem_post并
没有等待某些条件满足，它直接增加信号量的值，如果有等待线程就唤醒其中一个，当信号量的值为负数时，这个值就是等待线程的个数。
## 二值信号量（锁）
1. 信号量的第一种用法：用信号量作为锁。可以直接把临界区用一对sem_wait/sem_post环绕，注意初始化信号量的值，这个初始值为1。
假设有两个线程，第一个线程（线程0）调用了sem_wait，它把信号量的值减为0。然后它只会在值小于0时等待，因为值是0,调用线程从函数返回并
继续，线程0现在可以自由进入临界区。线程0在临界区中，如果没有其他线程尝试获取锁，当它调用sem_post时，会将信号量重置为1（因为
没有等待线程，不会唤醒其他线程）。
1. 如果线程0持有锁（即调用了sem_wait之后，调用sem_post之前），另一个线程（线程1）调用sem_wait尝试进入临界区，那么线程1
把信号量减为-1，然后等待（自己睡眠，放弃处理器）。线程0再次运行，它最终调用sem_post，将信号量的值增加到0，唤醒等待的线程
（线程1），然后线程1就可以获取锁。线程1执行结束时，再次增加信号量的值将它恢复为1。
1. 锁只有两个状态（持有和没持有），所以这种用法也叫作二值信号量。
## 信号量用作条件变量
1. 信号量也可以用在一个线程暂停执行等待某一条件成立的场景。如一个线程要等待一个链表非空，然后才能删除一个元素，这种情况下
通常一个线程等待条件成立，另外一个线程修改条件并发信号给等待线程，从而唤醒等待线程。因为等待线程在等待某些条件发生变化，所
以我们将信号量作为条件变量。
    ```
        sem_t s; 
        
        void *child(void *arg) {
            printf("child\n");
            sem_post(&s); // signal here: child is done
            return NULL;
        }
        
        int main(int argc, char *argv[]) {
            sem_init(&s, 0, X); // what should X be?
            printf("parent: begin\n");
            pthread_t c;
            Pthread_create(c, NULL, child, NULL);
            sem_wait(&s); // wait here for child
            printf("parent: end\n");
            return 0;
        }   
    ```
1. 在这种情况下信号量初始值应该是0，有两种情况：
    1. 父线程创建了子线程，但子线程并没有运行。父线程调用sem_wait会先于子线程调用sem_post。我们希望父线程等待子线程运行。
    此时唯一的办法是让信号量的值不大于0，因此0为初始值。父线程运行，将信号量减为-1，然后睡眠等待；子线程运行调用sem_post，
    信号量增加为0，唤醒父线程，父线程然后从sem_wait返回完成该程序。
    1. 子线程在父线程调用sem_wait之前运行结束，这种情况下，子线程会先调用sem_post，将信号量从0增加到1，然后当父线程有机会
    运行时，会调用sem_wait，发现信号量的值为1，于是父线程将信号量从1减为0，没有等待直接从sem_wait返回，也达到了预期效果。
