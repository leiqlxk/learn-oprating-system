## 简介
多级反馈队列（Multi-level Feedback Queue，MLFQ）：其首先要优化周转时间，并且希望给交互用户很好的体验，因此也需要降低
响应时间。轮转这样的算法虽然降低了响应时间，周转时间却很差。
## 基本原则
1. MLFQ中有许多独立的队列，每个队列有不同的优先级。任何时刻，一个工作只能存在于一个队列。MLFQ总是优先执行较高优先级的工
作。每个队列中的工作具有相同的优先级，这时采用轮转调度的方式进行调度。
1. MLFQ调度策略的关键在于如何设置优先级，其没有为每个工作制定不变的优先级而是根据观察到的行为调整工作的优先级。如一个工
作不断放弃CPU去等待键盘输入，这是交互型进程的可能行为，MLFQ因此会让它保持高优先级。相反，如果一个工作长时间地占用CPU,
MLFQ会降低其优先级。
1. MLFQ的两条基本规则：
    1. 规则1：如果A的优先级 > B的优先级，运行A（不运行B）
    1. 规则2：如果A的优先级 = B的优先级，轮转运行A和B
## 改变优先级
1. 规则：
    1. 规则3：工作进入系统时，放在最高优先级（最上层队列）
    1. 规则4a：工作用完整个时间片后，降低其优先级
    1. 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变
1. 上述规则会有饥饿问题，如果系统有太多交互型工作，就会不断占用CPU，导致长工作永远无法得到CPU（它们饿死了）。当然，也有
用户会利用这些规则来重写程序，愚弄调度程序。当进程在时间片用完之前，调用I/O操作，从而主动释放CPU，如此便可以保持在最高优
先级，占用更多的CPU时间，做得好的时工作可以几乎独占CPU。上述算法对此无能为力。
## 提升优先级
1. 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。
1. 该规则首先保证进程不会饿死，在最高优先级队列中，它会议轮转方式与其他高优先级工作分享CPU。其次如果一个CPU密集型工作变
成了交互型，当它优先级提升时，调度程序会正确对待它。
1. 此规则如果S设置的太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的CPU时间比例。
## 更好的计时方式
1. 之所以会出现调度程序被愚弄，这里是因为规则4a和规则4b，导致工作在时间片以内释放CPU，就保留它的优先级。可以采用为MLFQ
的每层队列提供更完善的CPU计时方式，调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了
自己的配额，就将它降低到低一优先级的队列中去。不论它是一次用完，还是拆成多次用完，则重写规则4a和4b。
1. 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级。
## MLFQ调优及其他问题
1. 
